{"mappings":"AAAA,MAAMA,EAAqB,CACzB,OACA,iBACA,gBACA,OACA,QACA,YACA,aACA,OACA,OACA,MACA,SACA,SACA,cAIF,SAASC,EAAMC,GACb,MAAO,CAACC,KAAM,OAAQC,MAAOF,EAAMG,KAAOH,EAAMI,OAAS,IAI3D,SAASC,EAAKL,GACZ,MAAO,CAACC,KAAM,OAAQC,MAAOF,EAAME,OAIrC,SAASI,EAAUN,GACjB,MAAO,CAACC,KAAM,YAAaM,SAAUP,EAAMO,UAI7C,SAASC,EAASR,GAChB,OAAOA,EAAMO,SAIf,SAASE,IACP,MAAO,CAACR,KAAM,OAAQC,MAAO,MAI/B,SAASQ,IACP,MAAO,CAACT,KAAM,OAAQC,MAAO,IAG/B,MAAMS,EACJC,aAAYC,UAACA,EAAYf,IACvBgB,KAAKC,IAAM,GAEXD,KAAKC,IAAIC,QAAUV,EACnBQ,KAAKC,IAAIE,KAAOZ,EAChBS,KAAKC,IAAIG,WAAab,EACtBS,KAAKC,IAAII,MAAQpB,EACjBe,KAAKC,IAAIK,eAAiBrB,EAC1Be,KAAKC,IAAIM,MAAQZ,EAEjBK,KAAKC,IAAIO,WAAad,EACtBM,KAAKC,IAAIQ,KAAOf,EAChBM,KAAKC,IAAIS,SAAWhB,EACpBM,KAAKC,IAAIU,OAASjB,EAClBM,KAAKC,IAAIW,SAAWlB,EACpBM,KAAKC,IAAIY,OAASnB,EAClBM,KAAKC,IAAIa,KAAOpB,EAChBM,KAAKC,IAAIc,cAAgBrB,EAEzBK,EAAUiB,SAAQC,IAChBjB,KAAKC,IAAIgB,GAAOrB,KAGlBI,KAAKkB,IAAMlB,KAAKkB,IAAIC,KAAKnB,MACzBA,KAAKoB,MAAQpB,KAAKoB,MAAMD,KAAKnB,MAC7BA,KAAKqB,IAAMrB,KAAKqB,IAAIF,KAAKnB,MAI3BkB,IAAII,GACF,IAAInC,EAAOmC,GAAQA,EAAKnC,KAcxB,OAZIA,KAAQa,KAAKC,MACfqB,EAAOtB,KAAKC,IAAId,GAAMmC,IAGpB,WAAYA,IACdA,EAAOtB,KAAKqB,IAAIC,IAGdA,EAAK7B,WACP6B,EAAK7B,SAAWO,KAAKqB,IAAIC,EAAK7B,WAGzB6B,EAITD,IAAIE,GACF,IAGInC,EAHAoC,GAAQ,EACRC,EAASF,EAAME,OACfC,EAAS,GAGb,OAASF,EAAQC,GACfrC,EAAQY,KAAKkB,IAAIK,EAAMC,IAEnBpC,GAAiC,iBAAjBA,EAAMqC,OACxBC,EAASA,EAAOC,OAAOvC,EAAMa,IAAID,KAAKkB,MAEtCQ,EAAOE,KAAKxC,GAIhB,OAAOY,KAAKoB,MAAMM,GAIpBN,MAAMS,GACJ,IAIIzC,EAJAoC,GAAQ,EACRC,EAASI,EAAOJ,OAChBC,EAAS,GACTI,EAAO,KAGX,OAASN,EAAQC,GACfrC,EAAQyC,EAAOL,GAEXM,GAAQ,UAAW1C,GAASA,EAAMD,OAAS2C,EAAK3C,KAClD2C,EAAK1C,OAASA,EAAMA,OAEpBsC,EAAOE,KAAKxC,GACZ0C,EAAO1C,GAIX,OAAOsC,GASXK,OAAAC,QALA,SAAejC,EAAYf,GAEzB,OADiB,IAAIa,EAAS,CA1IhCE,UA0IiCA,IACfmB,KAIlBa,OAAAC,QAAeC,mBAAqBjD","sources":["index.js"],"sourcesContent":["const DEFAULT_EMPTY_LIST = [\n  'code',\n  'horizontalRule',\n  'thematicBreak',\n  'html',\n  'table',\n  'tableCell',\n  'definition',\n  'yaml',\n  'toml',\n  'jsx',\n  'import',\n  'export',\n  'testchange'\n]\n\n/* Return an stringified image. */\nfunction image(token) {\n  return {type: 'text', value: token.alt || token.title || ''}\n}\n\n/* Return `token`s value. */\nfunction text(token) {\n  return {type: 'text', value: token.value}\n}\n\n/* Return a paragraph. */\nfunction paragraph(token) {\n  return {type: 'paragraph', children: token.children}\n}\n\n/* Return the concatenation of `token`s children. */\nfunction children(token) {\n  return token.children\n}\n\n/* Return line break. */\nfunction lineBreak() {\n  return {type: 'text', value: '\\n'}\n}\n\n/* Return nothing. */\nfunction empty() {\n  return {type: 'text', value: ''}\n}\n\nclass MDXStrip {\n  constructor({emptyList = DEFAULT_EMPTY_LIST}) {\n    this.map = {}\n\n    this.map.heading = paragraph\n    this.map.text = text\n    this.map.inlineCode = text\n    this.map.image = image\n    this.map.imageReference = image\n    this.map.break = lineBreak\n\n    this.map.blockquote = children\n    this.map.list = children\n    this.map.listItem = children\n    this.map.strong = children\n    this.map.emphasis = children\n    this.map.delete = children\n    this.map.link = children\n    this.map.linkReference = children\n\n    emptyList.forEach(key => {\n      this.map[key] = empty\n    })\n\n    this.one = this.one.bind(this)\n    this.clean = this.clean.bind(this)\n    this.all = this.all.bind(this)\n  }\n\n  /* One node. */\n  one(node) {\n    let type = node && node.type\n\n    if (type in this.map) {\n      node = this.map[type](node)\n    }\n\n    if ('length' in node) {\n      node = this.all(node)\n    }\n\n    if (node.children) {\n      node.children = this.all(node.children)\n    }\n\n    return node\n  }\n\n  /* Multiple nodes. */\n  all(nodes) {\n    let index = -1\n    let length = nodes.length\n    let result = []\n    let value\n\n    while (++index < length) {\n      value = this.one(nodes[index])\n\n      if (value && typeof value.length === 'number') {\n        result = result.concat(value.map(this.one))\n      } else {\n        result.push(value)\n      }\n    }\n\n    return this.clean(result)\n  }\n\n  /* Clean nodes: merges text's. */\n  clean(values) {\n    let index = -1\n    let length = values.length\n    let result = []\n    let prev = null\n    let value\n\n    while (++index < length) {\n      value = values[index]\n\n      if (prev && 'value' in value && value.type === prev.type) {\n        prev.value += value.value\n      } else {\n        result.push(value)\n        prev = value\n      }\n    }\n\n    return result\n  }\n}\n\nfunction strip(emptyList = DEFAULT_EMPTY_LIST) {\n  const mdxStrip = new MDXStrip({emptyList})\n  return mdxStrip.one\n}\n\nmodule.exports = strip\nmodule.exports.DEFAULT_EMPTY_LIST = DEFAULT_EMPTY_LIST\n"],"names":["$89eb665b0ad54191$var$DEFAULT_EMPTY_LIST","$89eb665b0ad54191$var$image","token","type","value","alt","title","$89eb665b0ad54191$var$text","$89eb665b0ad54191$var$paragraph","children","$89eb665b0ad54191$var$children","$89eb665b0ad54191$var$lineBreak","$89eb665b0ad54191$var$empty","$89eb665b0ad54191$var$MDXStrip","constructor","emptyList","this","map","heading","text","inlineCode","image","imageReference","break","blockquote","list","listItem","strong","emphasis","delete","link","linkReference","forEach","key","one","bind","clean","all","node","nodes","index","length","result","concat","push","values","prev","module","exports","DEFAULT_EMPTY_LIST"],"version":3,"file":"remark-mdx-to-plain-text.js.min.js.map"}