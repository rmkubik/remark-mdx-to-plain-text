{"mappings":"AAAA,MAAMA,EAAqB,CACzB,OACA,iBACA,gBACA,OACA,QACA,YACA,aACA,OACA,OACA,MACA,SACA,QACA,UAIF,SAASC,EAAMC,GACb,MAAO,CAACC,KAAM,OAAQC,MAAOF,EAAMG,KAAOH,EAAMI,OAAS,IAI3D,SAASC,EAAKL,GACZ,MAAO,CAACC,KAAM,OAAQC,MAAOF,EAAME,OAIrC,SAASI,EAAUN,GACjB,MAAO,CAACC,KAAM,YAAaM,SAAUP,EAAMO,UAI7C,SAASC,EAASR,GAChB,OAAOA,EAAMO,SAIf,SAASE,IACP,MAAO,CAACR,KAAM,OAAQC,MAAO,MAI/B,SAASQ,IACP,MAAO,CAACT,KAAM,OAAQC,MAAO,IAG/B,MAAMS,EACJC,aAAYC,UAACA,EAAYf,IACvBgB,KAAKC,IAAM,GAEXD,KAAKC,IAAIC,QAAUV,EACnBQ,KAAKC,IAAIE,KAAOZ,EAChBS,KAAKC,IAAIG,WAAab,EACtBS,KAAKC,IAAII,eAAiBpB,EAC1Be,KAAKC,IAAIK,MAAQX,EAEjBK,KAAKC,IAAIM,WAAab,EACtBM,KAAKC,IAAIO,KAAOd,EAChBM,KAAKC,IAAIQ,SAAWf,EACpBM,KAAKC,IAAIS,OAAShB,EAClBM,KAAKC,IAAIU,SAAWjB,EACpBM,KAAKC,IAAIW,OAASlB,EAClBM,KAAKC,IAAIY,KAAOnB,EAChBM,KAAKC,IAAIa,cAAgBpB,EAEzBK,EAAUgB,SAAQC,IAChBhB,KAAKC,IAAIe,GAAOpB,KAGlBI,KAAKiB,IAAMjB,KAAKiB,IAAIC,KAAKlB,MACzBA,KAAKmB,MAAQnB,KAAKmB,MAAMD,KAAKlB,MAC7BA,KAAKoB,IAAMpB,KAAKoB,IAAIF,KAAKlB,MAI3BiB,IAAII,GACF,IAAIlC,EAAOkC,GAAQA,EAAKlC,KAcxB,OAZIA,KAAQa,KAAKC,MACfoB,EAAOrB,KAAKC,IAAId,GAAMkC,IAGpB,WAAYA,IACdA,EAAOrB,KAAKoB,IAAIC,IAGdA,EAAK5B,WACP4B,EAAK5B,SAAWO,KAAKoB,IAAIC,EAAK5B,WAGzB4B,EAITD,IAAIE,GACF,IAGIlC,EAHAmC,GAAQ,EACRC,EAASF,EAAME,OACfC,EAAS,GAGb,OAASF,EAAQC,GACfpC,EAAQY,KAAKiB,IAAIK,EAAMC,IAEnBnC,GAAiC,iBAAjBA,EAAMoC,OACxBC,EAASA,EAAOC,OAAOtC,EAAMa,IAAID,KAAKiB,MAEtCQ,EAAOE,KAAKvC,GAIhB,OAAOY,KAAKmB,MAAMM,GAIpBN,MAAMS,GACJ,IAIIxC,EAJAmC,GAAQ,EACRC,EAASI,EAAOJ,OAChBC,EAAS,GACTI,EAAO,KAGX,OAASN,EAAQC,GACfpC,EAAQwC,EAAOL,GAEXM,GAAQ,UAAWzC,GAASA,EAAMD,OAAS0C,EAAK1C,KAClD0C,EAAKzC,OAASA,EAAMA,OAEpBqC,EAAOE,KAAKvC,GACZyC,EAAOzC,GAIX,OAAOqC,GASXK,OAAAC,QALA,SAAehC,EAAYf,GAEzB,OADiB,IAAIa,EAAS,CAzIhCE,UAyIiCA,IACfkB,KAIlBa,OAAAC,QAAeC,mBAAqBhD","sources":["index.js"],"sourcesContent":["const DEFAULT_EMPTY_LIST = [\n  'code',\n  'horizontalRule',\n  'thematicBreak',\n  'html',\n  'table',\n  'tableCell',\n  'definition',\n  'yaml',\n  'toml',\n  'jsx',\n  'import',\n  'image',\n  'export'\n]\n\n/* Return an stringified image. */\nfunction image(token) {\n  return {type: 'text', value: token.alt || token.title || ''}\n}\n\n/* Return `token`s value. */\nfunction text(token) {\n  return {type: 'text', value: token.value}\n}\n\n/* Return a paragraph. */\nfunction paragraph(token) {\n  return {type: 'paragraph', children: token.children}\n}\n\n/* Return the concatenation of `token`s children. */\nfunction children(token) {\n  return token.children\n}\n\n/* Return line break. */\nfunction lineBreak() {\n  return {type: 'text', value: '\\n'}\n}\n\n/* Return nothing. */\nfunction empty() {\n  return {type: 'text', value: ''}\n}\n\nclass MDXStrip {\n  constructor({emptyList = DEFAULT_EMPTY_LIST}) {\n    this.map = {}\n\n    this.map.heading = paragraph\n    this.map.text = text\n    this.map.inlineCode = text\n    this.map.imageReference = image\n    this.map.break = lineBreak\n\n    this.map.blockquote = children\n    this.map.list = children\n    this.map.listItem = children\n    this.map.strong = children\n    this.map.emphasis = children\n    this.map.delete = children\n    this.map.link = children\n    this.map.linkReference = children\n\n    emptyList.forEach(key => {\n      this.map[key] = empty\n    })\n\n    this.one = this.one.bind(this)\n    this.clean = this.clean.bind(this)\n    this.all = this.all.bind(this)\n  }\n\n  /* One node. */\n  one(node) {\n    let type = node && node.type\n\n    if (type in this.map) {\n      node = this.map[type](node)\n    }\n\n    if ('length' in node) {\n      node = this.all(node)\n    }\n\n    if (node.children) {\n      node.children = this.all(node.children)\n    }\n\n    return node\n  }\n\n  /* Multiple nodes. */\n  all(nodes) {\n    let index = -1\n    let length = nodes.length\n    let result = []\n    let value\n\n    while (++index < length) {\n      value = this.one(nodes[index])\n\n      if (value && typeof value.length === 'number') {\n        result = result.concat(value.map(this.one))\n      } else {\n        result.push(value)\n      }\n    }\n\n    return this.clean(result)\n  }\n\n  /* Clean nodes: merges text's. */\n  clean(values) {\n    let index = -1\n    let length = values.length\n    let result = []\n    let prev = null\n    let value\n\n    while (++index < length) {\n      value = values[index]\n\n      if (prev && 'value' in value && value.type === prev.type) {\n        prev.value += value.value\n      } else {\n        result.push(value)\n        prev = value\n      }\n    }\n\n    return result\n  }\n}\n\nfunction strip(emptyList = DEFAULT_EMPTY_LIST) {\n  const mdxStrip = new MDXStrip({emptyList})\n  return mdxStrip.one\n}\n\nmodule.exports = strip\nmodule.exports.DEFAULT_EMPTY_LIST = DEFAULT_EMPTY_LIST\n"],"names":["$89eb665b0ad54191$var$DEFAULT_EMPTY_LIST","$89eb665b0ad54191$var$image","token","type","value","alt","title","$89eb665b0ad54191$var$text","$89eb665b0ad54191$var$paragraph","children","$89eb665b0ad54191$var$children","$89eb665b0ad54191$var$lineBreak","$89eb665b0ad54191$var$empty","$89eb665b0ad54191$var$MDXStrip","constructor","emptyList","this","map","heading","text","inlineCode","imageReference","break","blockquote","list","listItem","strong","emphasis","delete","link","linkReference","forEach","key","one","bind","clean","all","node","nodes","index","length","result","concat","push","values","prev","module","exports","DEFAULT_EMPTY_LIST"],"version":3,"file":"remark-mdx-to-plain-text.js.min.js.map"}